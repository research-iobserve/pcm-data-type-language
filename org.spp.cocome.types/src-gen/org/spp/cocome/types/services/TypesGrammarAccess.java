/*
* generated by Xtext
*/
package org.spp.cocome.types.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class TypesGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameQualifiedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cImportsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cImportsImportParserRuleCall_2_0 = (RuleCall)cImportsAssignment_2.eContents().get(0);
		private final Assignment cTypesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypesComplexTypeParserRuleCall_3_0 = (RuleCall)cTypesAssignment_3.eContents().get(0);
		
		/// *
		// * see http://www.oiloftrop.de/tag/type-systems/ for details on the
		// * approach used to declare this language and type system
		// * / Model:
		//	"package" name=QualifiedName imports+=Import* types+=ComplexType*;
		public ParserRule getRule() { return rule; }

		//"package" name=QualifiedName imports+=Import* types+=ComplexType*
		public Group getGroup() { return cGroup; }

		//"package"
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }

		//name=QualifiedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_1_0() { return cNameQualifiedNameParserRuleCall_1_0; }

		//imports+=Import*
		public Assignment getImportsAssignment_2() { return cImportsAssignment_2; }

		//Import
		public RuleCall getImportsImportParserRuleCall_2_0() { return cImportsImportParserRuleCall_2_0; }

		//types+=ComplexType*
		public Assignment getTypesAssignment_3() { return cTypesAssignment_3; }

		//ComplexType
		public RuleCall getTypesComplexTypeParserRuleCall_3_0() { return cTypesComplexTypeParserRuleCall_3_0; }
	}

	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportedNamespaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0 = (RuleCall)cImportedNamespaceAssignment_1.eContents().get(0);
		
		//Import:
		//	"import" importedNamespace=QualifiedNameWithWildcard;
		public ParserRule getRule() { return rule; }

		//"import" importedNamespace=QualifiedNameWithWildcard
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//importedNamespace=QualifiedNameWithWildcard
		public Assignment getImportedNamespaceAssignment_1() { return cImportedNamespaceAssignment_1; }

		//QualifiedNameWithWildcard
		public RuleCall getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0() { return cImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNamedTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCollectionTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMapTypeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		/// * definition of the type system * / Type:
		//	NamedType | CollectionType | MapType;
		public ParserRule getRule() { return rule; }

		//NamedType | CollectionType | MapType
		public Alternatives getAlternatives() { return cAlternatives; }

		//NamedType
		public RuleCall getNamedTypeParserRuleCall_0() { return cNamedTypeParserRuleCall_0; }

		//CollectionType
		public RuleCall getCollectionTypeParserRuleCall_1() { return cCollectionTypeParserRuleCall_1; }

		//MapType
		public RuleCall getMapTypeParserRuleCall_2() { return cMapTypeParserRuleCall_2; }
	}

	public class NamedTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamedType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cComplexTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPrimitiveTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		/// * collection of named types * / NamedType:
		//	ComplexType | PrimitiveType;
		public ParserRule getRule() { return rule; }

		//ComplexType | PrimitiveType
		public Alternatives getAlternatives() { return cAlternatives; }

		//ComplexType
		public RuleCall getComplexTypeParserRuleCall_0() { return cComplexTypeParserRuleCall_0; }

		//PrimitiveType
		public RuleCall getPrimitiveTypeParserRuleCall_1() { return cPrimitiveTypeParserRuleCall_1; }
	}

	public class CollectionTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectionType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cReferenceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cReferenceTypeReferenceParserRuleCall_0_0 = (RuleCall)cReferenceAssignment_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSizeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSizeINTTerminalRuleCall_2_0 = (RuleCall)cSizeAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		/// * single dimensional collection type, no size results in an unbound collection * / CollectionType:
		//	reference=TypeReference "[" size=INT? "]";
		public ParserRule getRule() { return rule; }

		//reference=TypeReference "[" size=INT? "]"
		public Group getGroup() { return cGroup; }

		//reference=TypeReference
		public Assignment getReferenceAssignment_0() { return cReferenceAssignment_0; }

		//TypeReference
		public RuleCall getReferenceTypeReferenceParserRuleCall_0_0() { return cReferenceTypeReferenceParserRuleCall_0_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//size=INT?
		public Assignment getSizeAssignment_2() { return cSizeAssignment_2; }

		//INT
		public RuleCall getSizeINTTerminalRuleCall_2_0() { return cSizeINTTerminalRuleCall_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class MapTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MapType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cReferenceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cReferenceTypeReferenceParserRuleCall_0_0 = (RuleCall)cReferenceAssignment_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cMapTypeAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cMapTypeTypeReferenceParserRuleCall_2_0_0 = (RuleCall)cMapTypeAssignment_2_0.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cSizeAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cSizeINTTerminalRuleCall_4_0 = (RuleCall)cSizeAssignment_4.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//MapType:
		//	reference=TypeReference "<" (mapType=TypeReference ">") "[" size=INT? "]";
		public ParserRule getRule() { return rule; }

		//reference=TypeReference "<" (mapType=TypeReference ">") "[" size=INT? "]"
		public Group getGroup() { return cGroup; }

		//reference=TypeReference
		public Assignment getReferenceAssignment_0() { return cReferenceAssignment_0; }

		//TypeReference
		public RuleCall getReferenceTypeReferenceParserRuleCall_0_0() { return cReferenceTypeReferenceParserRuleCall_0_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }

		//mapType=TypeReference ">"
		public Group getGroup_2() { return cGroup_2; }

		//mapType=TypeReference
		public Assignment getMapTypeAssignment_2_0() { return cMapTypeAssignment_2_0; }

		//TypeReference
		public RuleCall getMapTypeTypeReferenceParserRuleCall_2_0_0() { return cMapTypeTypeReferenceParserRuleCall_2_0_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_2_1() { return cGreaterThanSignKeyword_2_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_3() { return cLeftSquareBracketKeyword_3; }

		//size=INT?
		public Assignment getSizeAssignment_4() { return cSizeAssignment_4; }

		//INT
		public RuleCall getSizeINTTerminalRuleCall_4_0() { return cSizeINTTerminalRuleCall_4_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_5() { return cRightSquareBracketKeyword_5; }
	}

	public class DeclarationTypeReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DeclarationTypeReference");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypeReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCollectionTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMapTypeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//DeclarationTypeReference:
		//	TypeReference | CollectionType | MapType;
		public ParserRule getRule() { return rule; }

		//TypeReference | CollectionType | MapType
		public Alternatives getAlternatives() { return cAlternatives; }

		//TypeReference
		public RuleCall getTypeReferenceParserRuleCall_0() { return cTypeReferenceParserRuleCall_0; }

		//CollectionType
		public RuleCall getCollectionTypeParserRuleCall_1() { return cCollectionTypeParserRuleCall_1; }

		//MapType
		public RuleCall getMapTypeParserRuleCall_2() { return cMapTypeParserRuleCall_2; }
	}

	public class TypeReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeReference");
		private final Assignment cReferenceAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cReferenceNamedTypeCrossReference_0 = (CrossReference)cReferenceAssignment.eContents().get(0);
		private final RuleCall cReferenceNamedTypeIDTerminalRuleCall_0_1 = (RuleCall)cReferenceNamedTypeCrossReference_0.eContents().get(1);
		
		/// * reference to a type * / TypeReference:
		//	reference=[NamedType];
		public ParserRule getRule() { return rule; }

		//reference=[NamedType]
		public Assignment getReferenceAssignment() { return cReferenceAssignment; }

		//[NamedType]
		public CrossReference getReferenceNamedTypeCrossReference_0() { return cReferenceNamedTypeCrossReference_0; }

		//ID
		public RuleCall getReferenceNamedTypeIDTerminalRuleCall_0_1() { return cReferenceNamedTypeIDTerminalRuleCall_0_1; }
	}

	public class PrimitiveTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveType");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		/// * helper rule to describe primitive types * / PrimitiveType:
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class ComplexTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComplexType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEnumerationTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEntityTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ComplexType:
		//	EnumerationType | EntityType;
		public ParserRule getRule() { return rule; }

		//EnumerationType | EntityType
		public Alternatives getAlternatives() { return cAlternatives; }

		//EnumerationType
		public RuleCall getEnumerationTypeParserRuleCall_0() { return cEnumerationTypeParserRuleCall_0; }

		//EntityType
		public RuleCall getEntityTypeParserRuleCall_1() { return cEntityTypeParserRuleCall_1; }
	}

	public class EnumerationTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cParentAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cParentEnumerationTypeCrossReference_2_1_0 = (CrossReference)cParentAssignment_2_1.eContents().get(0);
		private final RuleCall cParentEnumerationTypeQualifiedNameParserRuleCall_2_1_0_1 = (RuleCall)cParentEnumerationTypeCrossReference_2_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cLiteralsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cLiteralsEnumerationLiteralParserRuleCall_4_0 = (RuleCall)cLiteralsAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cLiteralsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cLiteralsEnumerationLiteralParserRuleCall_5_1_0 = (RuleCall)cLiteralsAssignment_5_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//EnumerationType:
		//	"enum" name=ID (":" parent=[EnumerationType|QualifiedName])? "{" literals+=EnumerationLiteral (","
		//	literals+=EnumerationLiteral)* "}";
		public ParserRule getRule() { return rule; }

		//"enum" name=ID (":" parent=[EnumerationType|QualifiedName])? "{" literals+=EnumerationLiteral (","
		//literals+=EnumerationLiteral)* "}"
		public Group getGroup() { return cGroup; }

		//"enum"
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//(":" parent=[EnumerationType|QualifiedName])?
		public Group getGroup_2() { return cGroup_2; }

		//":"
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }

		//parent=[EnumerationType|QualifiedName]
		public Assignment getParentAssignment_2_1() { return cParentAssignment_2_1; }

		//[EnumerationType|QualifiedName]
		public CrossReference getParentEnumerationTypeCrossReference_2_1_0() { return cParentEnumerationTypeCrossReference_2_1_0; }

		//QualifiedName
		public RuleCall getParentEnumerationTypeQualifiedNameParserRuleCall_2_1_0_1() { return cParentEnumerationTypeQualifiedNameParserRuleCall_2_1_0_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//literals+=EnumerationLiteral
		public Assignment getLiteralsAssignment_4() { return cLiteralsAssignment_4; }

		//EnumerationLiteral
		public RuleCall getLiteralsEnumerationLiteralParserRuleCall_4_0() { return cLiteralsEnumerationLiteralParserRuleCall_4_0; }

		//("," literals+=EnumerationLiteral)*
		public Group getGroup_5() { return cGroup_5; }

		//","
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }

		//literals+=EnumerationLiteral
		public Assignment getLiteralsAssignment_5_1() { return cLiteralsAssignment_5_1; }

		//EnumerationLiteral
		public RuleCall getLiteralsEnumerationLiteralParserRuleCall_5_1_0() { return cLiteralsEnumerationLiteralParserRuleCall_5_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class EnumerationLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerationLiteral");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//EnumerationLiteral:
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class EntityTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EntityType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEntityKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStorageModifierAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStorageModifierTypeStorageModifierEnumRuleCall_1_0 = (RuleCall)cStorageModifierAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cParentAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cParentComplexTypeCrossReference_3_1_0 = (CrossReference)cParentAssignment_3_1.eContents().get(0);
		private final RuleCall cParentComplexTypeQualifiedNameParserRuleCall_3_1_0_1 = (RuleCall)cParentComplexTypeCrossReference_3_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cPropertiesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cPropertiesPropertyParserRuleCall_5_0 = (RuleCall)cPropertiesAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		/// **
		// * The central entity type.
		// * / EntityType:
		//	"entity" storageModifier=TypeStorageModifier? name=ID (":" parent=[ComplexType|QualifiedName])? "{"
		//	properties+=Property* "}";
		public ParserRule getRule() { return rule; }

		//"entity" storageModifier=TypeStorageModifier? name=ID (":" parent=[ComplexType|QualifiedName])? "{"
		//properties+=Property* "}"
		public Group getGroup() { return cGroup; }

		//"entity"
		public Keyword getEntityKeyword_0() { return cEntityKeyword_0; }

		//storageModifier=TypeStorageModifier?
		public Assignment getStorageModifierAssignment_1() { return cStorageModifierAssignment_1; }

		//TypeStorageModifier
		public RuleCall getStorageModifierTypeStorageModifierEnumRuleCall_1_0() { return cStorageModifierTypeStorageModifierEnumRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//(":" parent=[ComplexType|QualifiedName])?
		public Group getGroup_3() { return cGroup_3; }

		//":"
		public Keyword getColonKeyword_3_0() { return cColonKeyword_3_0; }

		//parent=[ComplexType|QualifiedName]
		public Assignment getParentAssignment_3_1() { return cParentAssignment_3_1; }

		//[ComplexType|QualifiedName]
		public CrossReference getParentComplexTypeCrossReference_3_1_0() { return cParentComplexTypeCrossReference_3_1_0; }

		//QualifiedName
		public RuleCall getParentComplexTypeQualifiedNameParserRuleCall_3_1_0_1() { return cParentComplexTypeQualifiedNameParserRuleCall_3_1_0_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//properties+=Property*
		public Assignment getPropertiesAssignment_5() { return cPropertiesAssignment_5; }

		//Property
		public RuleCall getPropertiesPropertyParserRuleCall_5_0() { return cPropertiesPropertyParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class PropertyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Property");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStorageModifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStorageModifierPropertyStorageModifierEnumRuleCall_0_0 = (RuleCall)cStorageModifierAssignment_0.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeDeclarationTypeReferenceParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cRelationshipAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRelationshipEntityRelationshipParserRuleCall_3_0 = (RuleCall)cRelationshipAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cOrderKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cOrderByAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cOrderByPropertyReferenceParserRuleCall_4_1_0 = (RuleCall)cOrderByAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cKeyKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cMapKeyAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cMapKeyPropertyReferenceParserRuleCall_5_1_0 = (RuleCall)cMapKeyAssignment_5_1.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cEqualsSignKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cLiteralAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cLiteralLiteralParserRuleCall_6_1_0 = (RuleCall)cLiteralAssignment_6_1.eContents().get(0);
		
		/// **
		// * A unique property with UniquePropertyOption::mappedBy uses a foreign property. 
		// * / Property:
		//	storageModifier=PropertyStorageModifier? type=DeclarationTypeReference name=ID relationship=EntityRelationship?
		//	("order" orderBy=PropertyReference)? // @OrderBy
		//	("key" mapKey=PropertyReference)? // @MapKey
		//	("=" literal=Literal)?;
		public ParserRule getRule() { return rule; }

		//storageModifier=PropertyStorageModifier? type=DeclarationTypeReference name=ID relationship=EntityRelationship? ("order"
		//orderBy=PropertyReference)? // @OrderBy
		//("key" mapKey=PropertyReference)? // @MapKey
		//("=" literal=Literal)?
		public Group getGroup() { return cGroup; }

		//storageModifier=PropertyStorageModifier?
		public Assignment getStorageModifierAssignment_0() { return cStorageModifierAssignment_0; }

		//PropertyStorageModifier
		public RuleCall getStorageModifierPropertyStorageModifierEnumRuleCall_0_0() { return cStorageModifierPropertyStorageModifierEnumRuleCall_0_0; }

		//type=DeclarationTypeReference
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//DeclarationTypeReference
		public RuleCall getTypeDeclarationTypeReferenceParserRuleCall_1_0() { return cTypeDeclarationTypeReferenceParserRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//relationship=EntityRelationship?
		public Assignment getRelationshipAssignment_3() { return cRelationshipAssignment_3; }

		//EntityRelationship
		public RuleCall getRelationshipEntityRelationshipParserRuleCall_3_0() { return cRelationshipEntityRelationshipParserRuleCall_3_0; }

		//("order" orderBy=PropertyReference)?
		public Group getGroup_4() { return cGroup_4; }

		//"order"
		public Keyword getOrderKeyword_4_0() { return cOrderKeyword_4_0; }

		//orderBy=PropertyReference
		public Assignment getOrderByAssignment_4_1() { return cOrderByAssignment_4_1; }

		//PropertyReference
		public RuleCall getOrderByPropertyReferenceParserRuleCall_4_1_0() { return cOrderByPropertyReferenceParserRuleCall_4_1_0; }

		//("key" mapKey=PropertyReference)?
		public Group getGroup_5() { return cGroup_5; }

		//"key"
		public Keyword getKeyKeyword_5_0() { return cKeyKeyword_5_0; }

		//mapKey=PropertyReference
		public Assignment getMapKeyAssignment_5_1() { return cMapKeyAssignment_5_1; }

		//PropertyReference
		public RuleCall getMapKeyPropertyReferenceParserRuleCall_5_1_0() { return cMapKeyPropertyReferenceParserRuleCall_5_1_0; }

		//("=" literal=Literal)?
		public Group getGroup_6() { return cGroup_6; }

		//"="
		public Keyword getEqualsSignKeyword_6_0() { return cEqualsSignKeyword_6_0; }

		//literal=Literal
		public Assignment getLiteralAssignment_6_1() { return cLiteralAssignment_6_1; }

		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_6_1_0() { return cLiteralLiteralParserRuleCall_6_1_0; }
	}

	public class EntityRelationshipElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EntityRelationship");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEntityRelationshipAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cKindAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cKindEntityRelationshipKindEnumRuleCall_1_0 = (RuleCall)cKindAssignment_1.eContents().get(0);
		private final Assignment cMappedByAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMappedByMappedByReferenceParserRuleCall_2_0 = (RuleCall)cMappedByAssignment_2.eContents().get(0);
		
		/// **
		// * Specifying mappedBy indicates a back references.
		// * / EntityRelationship:
		//	{EntityRelationship} kind=EntityRelationshipKind mappedBy=MappedByReference?;
		public ParserRule getRule() { return rule; }

		//{EntityRelationship} kind=EntityRelationshipKind mappedBy=MappedByReference?
		public Group getGroup() { return cGroup; }

		//{EntityRelationship}
		public Action getEntityRelationshipAction_0() { return cEntityRelationshipAction_0; }

		//kind=EntityRelationshipKind
		public Assignment getKindAssignment_1() { return cKindAssignment_1; }

		//EntityRelationshipKind
		public RuleCall getKindEntityRelationshipKindEnumRuleCall_1_0() { return cKindEntityRelationshipKindEnumRuleCall_1_0; }

		//mappedBy=MappedByReference?
		public Assignment getMappedByAssignment_2() { return cMappedByAssignment_2; }

		//MappedByReference
		public RuleCall getMappedByMappedByReferenceParserRuleCall_2_0() { return cMappedByMappedByReferenceParserRuleCall_2_0; }
	}

	public class MappedByReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MappedByReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cBaseAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cBasePropertyCrossReference_0_0 = (CrossReference)cBaseAssignment_0.eContents().get(0);
		private final RuleCall cBasePropertyIDTerminalRuleCall_0_0_1 = (RuleCall)cBasePropertyCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cPathAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPathMappedByReferenceParserRuleCall_1_1_0 = (RuleCall)cPathAssignment_1_1.eContents().get(0);
		
		//MappedByReference:
		//	base=[Property] ("." path=MappedByReference)?;
		public ParserRule getRule() { return rule; }

		//base=[Property] ("." path=MappedByReference)?
		public Group getGroup() { return cGroup; }

		//base=[Property]
		public Assignment getBaseAssignment_0() { return cBaseAssignment_0; }

		//[Property]
		public CrossReference getBasePropertyCrossReference_0_0() { return cBasePropertyCrossReference_0_0; }

		//ID
		public RuleCall getBasePropertyIDTerminalRuleCall_0_0_1() { return cBasePropertyIDTerminalRuleCall_0_0_1; }

		//("." path=MappedByReference)?
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//path=MappedByReference
		public Assignment getPathAssignment_1_1() { return cPathAssignment_1_1; }

		//MappedByReference
		public RuleCall getPathMappedByReferenceParserRuleCall_1_1_0() { return cPathMappedByReferenceParserRuleCall_1_1_0; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNumberLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCharLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cStringLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPropertyReferenceParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Literal:
		//	BooleanLiteral | NumberLiteral | CharLiteral | StringLiteral | PropertyReference;
		public ParserRule getRule() { return rule; }

		//BooleanLiteral | NumberLiteral | CharLiteral | StringLiteral | PropertyReference
		public Alternatives getAlternatives() { return cAlternatives; }

		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_0() { return cBooleanLiteralParserRuleCall_0; }

		//NumberLiteral
		public RuleCall getNumberLiteralParserRuleCall_1() { return cNumberLiteralParserRuleCall_1; }

		//CharLiteral
		public RuleCall getCharLiteralParserRuleCall_2() { return cCharLiteralParserRuleCall_2; }

		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_3() { return cStringLiteralParserRuleCall_3; }

		//PropertyReference
		public RuleCall getPropertyReferenceParserRuleCall_4() { return cPropertyReferenceParserRuleCall_4; }
	}

	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StringLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringLiteral:
		//	value=STRING;
		public ParserRule getRule() { return rule; }

		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }

		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}

	public class CharLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CharLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueCHARACTERTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//CharLiteral:
		//	value=CHARACTER;
		public ParserRule getRule() { return rule; }

		//value=CHARACTER
		public Assignment getValueAssignment() { return cValueAssignment; }

		//CHARACTER
		public RuleCall getValueCHARACTERTerminalRuleCall_0() { return cValueCHARACTERTerminalRuleCall_0; }
	}

	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumberLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueNUMBERParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//NumberLiteral:
		//	value=NUMBER;
		public ParserRule getRule() { return rule; }

		//value=NUMBER
		public Assignment getValueAssignment() { return cValueAssignment; }

		//NUMBER
		public RuleCall getValueNUMBERParserRuleCall_0() { return cValueNUMBERParserRuleCall_0; }
	}

	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBOOLEANParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BooleanLiteral:
		//	value=BOOLEAN;
		public ParserRule getRule() { return rule; }

		//value=BOOLEAN
		public Assignment getValueAssignment() { return cValueAssignment; }

		//BOOLEAN
		public RuleCall getValueBOOLEANParserRuleCall_0() { return cValueBOOLEANParserRuleCall_0; }
	}

	public class PropertyReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyReference");
		private final Assignment cReferenceAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cReferencePropertyCrossReference_0 = (CrossReference)cReferenceAssignment.eContents().get(0);
		private final RuleCall cReferencePropertyIDTerminalRuleCall_0_1 = (RuleCall)cReferencePropertyCrossReference_0.eContents().get(1);
		
		//PropertyReference:
		//	reference=[Property];
		public ParserRule getRule() { return rule; }

		//reference=[Property]
		public Assignment getReferenceAssignment() { return cReferenceAssignment; }

		//[Property]
		public CrossReference getReferencePropertyCrossReference_0() { return cReferencePropertyCrossReference_0; }

		//ID
		public RuleCall getReferencePropertyIDTerminalRuleCall_0_1() { return cReferencePropertyIDTerminalRuleCall_0_1; }
	}

	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		/// *
		// * special rules
		// * / QualifiedName:
		//	ID ("." ID)*;
		public ParserRule getRule() { return rule; }

		//ID ("." ID)*
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//("." ID)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}

	public class QualifiedNameWithWildcardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QualifiedNameWithWildcard");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//QualifiedNameWithWildcard:
		//	QualifiedName ("." "*")?;
		public ParserRule getRule() { return rule; }

		//QualifiedName ("." "*")?
		public Group getGroup() { return cGroup; }

		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_0() { return cQualifiedNameParserRuleCall_0; }

		//("." "*")?
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }
	}

	public class BOOLEANElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BOOLEAN returns ecore::EBoolean:
		//	"true" | "false";
		public ParserRule getRule() { return rule; }

		//"true" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class NUMBERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_0_0_0 = (Keyword)cAlternatives_0_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_0_1 = (Keyword)cAlternatives_0_0.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//NUMBER:
		//	("+" | "-")? INT | INT "." INT;
		public ParserRule getRule() { return rule; }

		//("+" | "-")? INT | INT "." INT
		public Alternatives getAlternatives() { return cAlternatives; }

		//("+" | "-")? INT
		public Group getGroup_0() { return cGroup_0; }

		//("+" | "-")?
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//"+"
		public Keyword getPlusSignKeyword_0_0_0() { return cPlusSignKeyword_0_0_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_0_0_1() { return cHyphenMinusKeyword_0_0_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_1() { return cINTTerminalRuleCall_0_1; }

		//INT "." INT
		public Group getGroup_1() { return cGroup_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_0() { return cINTTerminalRuleCall_1_0; }

		//"."
		public Keyword getFullStopKeyword_1_1() { return cFullStopKeyword_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_2() { return cINTTerminalRuleCall_1_2; }
	}
	
	
	public class TypeStorageModifierElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "TypeStorageModifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSTORABLEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSTORABLEStorableKeyword_0_0 = (Keyword)cSTORABLEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cEMBEDDABLEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cEMBEDDABLEEmbeddableKeyword_1_0 = (Keyword)cEMBEDDABLEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum TypeStorageModifier:
		//	STORABLE=" storable" // The entity type will be mapped to a table.
		//	| EMBEDDABLE= // The properties of the entity type will be embedded in another entity table. This only makes sense for one to one relationships.
		//	"embeddable";
		public EnumRule getRule() { return rule; }

		//STORABLE=" storable" // The entity type will be mapped to a table.
		//| EMBEDDABLE= // The properties of the entity type will be embedded in another entity table. This only makes sense for one to one relationships.
		//"embeddable"
		public Alternatives getAlternatives() { return cAlternatives; }

		//STORABLE=" storable"
		public EnumLiteralDeclaration getSTORABLEEnumLiteralDeclaration_0() { return cSTORABLEEnumLiteralDeclaration_0; }

		//" storable"
		public Keyword getSTORABLEStorableKeyword_0_0() { return cSTORABLEStorableKeyword_0_0; }

		//EMBEDDABLE= // The properties of the entity type will be embedded in another entity table. This only makes sense for one to one relationships.
		//"embeddable"
		public EnumLiteralDeclaration getEMBEDDABLEEnumLiteralDeclaration_1() { return cEMBEDDABLEEnumLiteralDeclaration_1; }

		//// The properties of the entity type will be embedded in another entity table. This only makes sense for one to one relationships.
		//"embeddable"
		public Keyword getEMBEDDABLEEmbeddableKeyword_1_0() { return cEMBEDDABLEEmbeddableKeyword_1_0; }
	}

	public class EntityRelationshipKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "EntityRelationshipKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cUNIQUEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cUNIQUEUniqueKeyword_0_0 = (Keyword)cUNIQUEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMANYEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMANYManyKeyword_1_0 = (Keyword)cMANYEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum EntityRelationshipKind:
		//	UNIQUE="unique" | MANY="many";
		public EnumRule getRule() { return rule; }

		//UNIQUE="unique" | MANY="many"
		public Alternatives getAlternatives() { return cAlternatives; }

		//UNIQUE="unique"
		public EnumLiteralDeclaration getUNIQUEEnumLiteralDeclaration_0() { return cUNIQUEEnumLiteralDeclaration_0; }

		//"unique"
		public Keyword getUNIQUEUniqueKeyword_0_0() { return cUNIQUEUniqueKeyword_0_0; }

		//MANY="many"
		public EnumLiteralDeclaration getMANYEnumLiteralDeclaration_1() { return cMANYEnumLiteralDeclaration_1; }

		//"many"
		public Keyword getMANYManyKeyword_1_0() { return cMANYManyKeyword_1_0; }
	}

	public class PropertyStorageModifierElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyStorageModifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cVARIABLEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cVARIABLEVarKeyword_0_0 = (Keyword)cVARIABLEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cVALUEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cVALUEValKeyword_1_0 = (Keyword)cVALUEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cTRANSIENTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cTRANSIENTTransientKeyword_2_0 = (Keyword)cTRANSIENTEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum PropertyStorageModifier:
		//	VARIABLE="var" // The property can be changed any time, this option is the default.
		//	// The property can only be set once. It implies transient, as it is realized with 'final'
		//	| VALUE="val" | TRANSIENT= // The property shall not be stored in the database.
		//	"transient";
		public EnumRule getRule() { return rule; }

		//VARIABLE="var" // The property can be changed any time, this option is the default.
		//// The property can only be set once. It implies transient, as it is realized with 'final'
		//| VALUE="val" | TRANSIENT= // The property shall not be stored in the database.
		//"transient"
		public Alternatives getAlternatives() { return cAlternatives; }

		//VARIABLE="var"
		public EnumLiteralDeclaration getVARIABLEEnumLiteralDeclaration_0() { return cVARIABLEEnumLiteralDeclaration_0; }

		//"var"
		public Keyword getVARIABLEVarKeyword_0_0() { return cVARIABLEVarKeyword_0_0; }

		//VALUE="val"
		public EnumLiteralDeclaration getVALUEEnumLiteralDeclaration_1() { return cVALUEEnumLiteralDeclaration_1; }

		//"val"
		public Keyword getVALUEValKeyword_1_0() { return cVALUEValKeyword_1_0; }

		//TRANSIENT= // The property shall not be stored in the database.
		//"transient"
		public EnumLiteralDeclaration getTRANSIENTEnumLiteralDeclaration_2() { return cTRANSIENTEnumLiteralDeclaration_2; }

		//// The property shall not be stored in the database.
		//"transient"
		public Keyword getTRANSIENTTransientKeyword_2_0() { return cTRANSIENTTransientKeyword_2_0; }
	}
	
	private ModelElements pModel;
	private ImportElements pImport;
	private TypeElements pType;
	private NamedTypeElements pNamedType;
	private CollectionTypeElements pCollectionType;
	private MapTypeElements pMapType;
	private DeclarationTypeReferenceElements pDeclarationTypeReference;
	private TypeReferenceElements pTypeReference;
	private PrimitiveTypeElements pPrimitiveType;
	private ComplexTypeElements pComplexType;
	private EnumerationTypeElements pEnumerationType;
	private EnumerationLiteralElements pEnumerationLiteral;
	private EntityTypeElements pEntityType;
	private TypeStorageModifierElements unknownRuleTypeStorageModifier;
	private PropertyElements pProperty;
	private EntityRelationshipElements pEntityRelationship;
	private EntityRelationshipKindElements unknownRuleEntityRelationshipKind;
	private MappedByReferenceElements pMappedByReference;
	private PropertyStorageModifierElements unknownRulePropertyStorageModifier;
	private LiteralElements pLiteral;
	private StringLiteralElements pStringLiteral;
	private CharLiteralElements pCharLiteral;
	private NumberLiteralElements pNumberLiteral;
	private BooleanLiteralElements pBooleanLiteral;
	private PropertyReferenceElements pPropertyReference;
	private QualifiedNameElements pQualifiedName;
	private QualifiedNameWithWildcardElements pQualifiedNameWithWildcard;
	private BOOLEANElements pBOOLEAN;
	private NUMBERElements pNUMBER;
	private TerminalRule tCHARACTER;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public TypesGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.spp.cocome.types.Types".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	/// *
	// * see http://www.oiloftrop.de/tag/type-systems/ for details on the
	// * approach used to declare this language and type system
	// * / Model:
	//	"package" name=QualifiedName imports+=Import* types+=ComplexType*;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//Import:
	//	"import" importedNamespace=QualifiedNameWithWildcard;
	public ImportElements getImportAccess() {
		return (pImport != null) ? pImport : (pImport = new ImportElements());
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	/// * definition of the type system * / Type:
	//	NamedType | CollectionType | MapType;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	/// * collection of named types * / NamedType:
	//	ComplexType | PrimitiveType;
	public NamedTypeElements getNamedTypeAccess() {
		return (pNamedType != null) ? pNamedType : (pNamedType = new NamedTypeElements());
	}
	
	public ParserRule getNamedTypeRule() {
		return getNamedTypeAccess().getRule();
	}

	/// * single dimensional collection type, no size results in an unbound collection * / CollectionType:
	//	reference=TypeReference "[" size=INT? "]";
	public CollectionTypeElements getCollectionTypeAccess() {
		return (pCollectionType != null) ? pCollectionType : (pCollectionType = new CollectionTypeElements());
	}
	
	public ParserRule getCollectionTypeRule() {
		return getCollectionTypeAccess().getRule();
	}

	//MapType:
	//	reference=TypeReference "<" (mapType=TypeReference ">") "[" size=INT? "]";
	public MapTypeElements getMapTypeAccess() {
		return (pMapType != null) ? pMapType : (pMapType = new MapTypeElements());
	}
	
	public ParserRule getMapTypeRule() {
		return getMapTypeAccess().getRule();
	}

	//DeclarationTypeReference:
	//	TypeReference | CollectionType | MapType;
	public DeclarationTypeReferenceElements getDeclarationTypeReferenceAccess() {
		return (pDeclarationTypeReference != null) ? pDeclarationTypeReference : (pDeclarationTypeReference = new DeclarationTypeReferenceElements());
	}
	
	public ParserRule getDeclarationTypeReferenceRule() {
		return getDeclarationTypeReferenceAccess().getRule();
	}

	/// * reference to a type * / TypeReference:
	//	reference=[NamedType];
	public TypeReferenceElements getTypeReferenceAccess() {
		return (pTypeReference != null) ? pTypeReference : (pTypeReference = new TypeReferenceElements());
	}
	
	public ParserRule getTypeReferenceRule() {
		return getTypeReferenceAccess().getRule();
	}

	/// * helper rule to describe primitive types * / PrimitiveType:
	//	name=ID;
	public PrimitiveTypeElements getPrimitiveTypeAccess() {
		return (pPrimitiveType != null) ? pPrimitiveType : (pPrimitiveType = new PrimitiveTypeElements());
	}
	
	public ParserRule getPrimitiveTypeRule() {
		return getPrimitiveTypeAccess().getRule();
	}

	//ComplexType:
	//	EnumerationType | EntityType;
	public ComplexTypeElements getComplexTypeAccess() {
		return (pComplexType != null) ? pComplexType : (pComplexType = new ComplexTypeElements());
	}
	
	public ParserRule getComplexTypeRule() {
		return getComplexTypeAccess().getRule();
	}

	//EnumerationType:
	//	"enum" name=ID (":" parent=[EnumerationType|QualifiedName])? "{" literals+=EnumerationLiteral (","
	//	literals+=EnumerationLiteral)* "}";
	public EnumerationTypeElements getEnumerationTypeAccess() {
		return (pEnumerationType != null) ? pEnumerationType : (pEnumerationType = new EnumerationTypeElements());
	}
	
	public ParserRule getEnumerationTypeRule() {
		return getEnumerationTypeAccess().getRule();
	}

	//EnumerationLiteral:
	//	name=ID;
	public EnumerationLiteralElements getEnumerationLiteralAccess() {
		return (pEnumerationLiteral != null) ? pEnumerationLiteral : (pEnumerationLiteral = new EnumerationLiteralElements());
	}
	
	public ParserRule getEnumerationLiteralRule() {
		return getEnumerationLiteralAccess().getRule();
	}

	/// **
	// * The central entity type.
	// * / EntityType:
	//	"entity" storageModifier=TypeStorageModifier? name=ID (":" parent=[ComplexType|QualifiedName])? "{"
	//	properties+=Property* "}";
	public EntityTypeElements getEntityTypeAccess() {
		return (pEntityType != null) ? pEntityType : (pEntityType = new EntityTypeElements());
	}
	
	public ParserRule getEntityTypeRule() {
		return getEntityTypeAccess().getRule();
	}

	//enum TypeStorageModifier:
	//	STORABLE=" storable" // The entity type will be mapped to a table.
	//	| EMBEDDABLE= // The properties of the entity type will be embedded in another entity table. This only makes sense for one to one relationships.
	//	"embeddable";
	public TypeStorageModifierElements getTypeStorageModifierAccess() {
		return (unknownRuleTypeStorageModifier != null) ? unknownRuleTypeStorageModifier : (unknownRuleTypeStorageModifier = new TypeStorageModifierElements());
	}
	
	public EnumRule getTypeStorageModifierRule() {
		return getTypeStorageModifierAccess().getRule();
	}

	/// **
	// * A unique property with UniquePropertyOption::mappedBy uses a foreign property. 
	// * / Property:
	//	storageModifier=PropertyStorageModifier? type=DeclarationTypeReference name=ID relationship=EntityRelationship?
	//	("order" orderBy=PropertyReference)? // @OrderBy
	//	("key" mapKey=PropertyReference)? // @MapKey
	//	("=" literal=Literal)?;
	public PropertyElements getPropertyAccess() {
		return (pProperty != null) ? pProperty : (pProperty = new PropertyElements());
	}
	
	public ParserRule getPropertyRule() {
		return getPropertyAccess().getRule();
	}

	/// **
	// * Specifying mappedBy indicates a back references.
	// * / EntityRelationship:
	//	{EntityRelationship} kind=EntityRelationshipKind mappedBy=MappedByReference?;
	public EntityRelationshipElements getEntityRelationshipAccess() {
		return (pEntityRelationship != null) ? pEntityRelationship : (pEntityRelationship = new EntityRelationshipElements());
	}
	
	public ParserRule getEntityRelationshipRule() {
		return getEntityRelationshipAccess().getRule();
	}

	//enum EntityRelationshipKind:
	//	UNIQUE="unique" | MANY="many";
	public EntityRelationshipKindElements getEntityRelationshipKindAccess() {
		return (unknownRuleEntityRelationshipKind != null) ? unknownRuleEntityRelationshipKind : (unknownRuleEntityRelationshipKind = new EntityRelationshipKindElements());
	}
	
	public EnumRule getEntityRelationshipKindRule() {
		return getEntityRelationshipKindAccess().getRule();
	}

	//MappedByReference:
	//	base=[Property] ("." path=MappedByReference)?;
	public MappedByReferenceElements getMappedByReferenceAccess() {
		return (pMappedByReference != null) ? pMappedByReference : (pMappedByReference = new MappedByReferenceElements());
	}
	
	public ParserRule getMappedByReferenceRule() {
		return getMappedByReferenceAccess().getRule();
	}

	//enum PropertyStorageModifier:
	//	VARIABLE="var" // The property can be changed any time, this option is the default.
	//	// The property can only be set once. It implies transient, as it is realized with 'final'
	//	| VALUE="val" | TRANSIENT= // The property shall not be stored in the database.
	//	"transient";
	public PropertyStorageModifierElements getPropertyStorageModifierAccess() {
		return (unknownRulePropertyStorageModifier != null) ? unknownRulePropertyStorageModifier : (unknownRulePropertyStorageModifier = new PropertyStorageModifierElements());
	}
	
	public EnumRule getPropertyStorageModifierRule() {
		return getPropertyStorageModifierAccess().getRule();
	}

	//Literal:
	//	BooleanLiteral | NumberLiteral | CharLiteral | StringLiteral | PropertyReference;
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//StringLiteral:
	//	value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return (pStringLiteral != null) ? pStringLiteral : (pStringLiteral = new StringLiteralElements());
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//CharLiteral:
	//	value=CHARACTER;
	public CharLiteralElements getCharLiteralAccess() {
		return (pCharLiteral != null) ? pCharLiteral : (pCharLiteral = new CharLiteralElements());
	}
	
	public ParserRule getCharLiteralRule() {
		return getCharLiteralAccess().getRule();
	}

	//NumberLiteral:
	//	value=NUMBER;
	public NumberLiteralElements getNumberLiteralAccess() {
		return (pNumberLiteral != null) ? pNumberLiteral : (pNumberLiteral = new NumberLiteralElements());
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}

	//BooleanLiteral:
	//	value=BOOLEAN;
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return (pBooleanLiteral != null) ? pBooleanLiteral : (pBooleanLiteral = new BooleanLiteralElements());
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	//PropertyReference:
	//	reference=[Property];
	public PropertyReferenceElements getPropertyReferenceAccess() {
		return (pPropertyReference != null) ? pPropertyReference : (pPropertyReference = new PropertyReferenceElements());
	}
	
	public ParserRule getPropertyReferenceRule() {
		return getPropertyReferenceAccess().getRule();
	}

	/// *
	// * special rules
	// * / QualifiedName:
	//	ID ("." ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return (pQualifiedName != null) ? pQualifiedName : (pQualifiedName = new QualifiedNameElements());
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}

	//QualifiedNameWithWildcard:
	//	QualifiedName ("." "*")?;
	public QualifiedNameWithWildcardElements getQualifiedNameWithWildcardAccess() {
		return (pQualifiedNameWithWildcard != null) ? pQualifiedNameWithWildcard : (pQualifiedNameWithWildcard = new QualifiedNameWithWildcardElements());
	}
	
	public ParserRule getQualifiedNameWithWildcardRule() {
		return getQualifiedNameWithWildcardAccess().getRule();
	}

	//BOOLEAN returns ecore::EBoolean:
	//	"true" | "false";
	public BOOLEANElements getBOOLEANAccess() {
		return (pBOOLEAN != null) ? pBOOLEAN : (pBOOLEAN = new BOOLEANElements());
	}
	
	public ParserRule getBOOLEANRule() {
		return getBOOLEANAccess().getRule();
	}

	//NUMBER:
	//	("+" | "-")? INT | INT "." INT;
	public NUMBERElements getNUMBERAccess() {
		return (pNUMBER != null) ? pNUMBER : (pNUMBER = new NUMBERElements());
	}
	
	public ParserRule getNUMBERRule() {
		return getNUMBERAccess().getRule();
	}

	//terminal CHARACTER:
	//	"\'" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'")) "\'";
	public TerminalRule getCHARACTERRule() {
		return (tCHARACTER != null) ? tCHARACTER : (tCHARACTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CHARACTER"));
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
