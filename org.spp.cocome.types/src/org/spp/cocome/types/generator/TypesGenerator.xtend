/*
 * generated by Xtext
 */
package org.spp.cocome.types.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.spp.cocome.types.types.EntityType
import org.spp.cocome.types.types.Model
import java.io.File
import org.spp.cocome.types.types.Import
import org.spp.cocome.types.types.Property
import org.spp.cocome.types.types.TypeReference
import org.spp.cocome.types.types.CollectionType
import org.spp.cocome.types.types.Literal
import org.spp.cocome.types.types.BooleanLiteral
import org.spp.cocome.types.types.NumberLiteral
import org.spp.cocome.types.types.CharLiteral
import org.spp.cocome.types.types.StringLiteral
import org.spp.cocome.types.types.PropertyReference
import org.spp.cocome.types.types.PrimitiveType
import org.spp.cocome.types.types.TypeStorageModifier
import org.spp.cocome.types.types.PropertyStorageModifier
import org.spp.cocome.types.types.EnumerationType
import org.spp.cocome.types.types.MappedByReference
import org.spp.cocome.types.types.MapType
import org.spp.cocome.types.types.EntityRelationshipKind

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class TypesGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		resource.allContents.filter(typeof(EntityType)).forEach[EntityType e | fsa.generateFile(e.createFileName,e.createEntity)]
	}
	
	def createFileName(EntityType type) {
		(type.eContainer as Model).name.replace('.',File::separator) + File::separator + type.name + '.java'
	}
	
	def createEntity(EntityType type) '''
		package «(type.eContainer as Model).name»;
		
		import java.sql.Date;
		import java.util.List;
		«type.storageModifier.createImports»
		
		«(type.eContainer as Model).imports.map[i | i.createImport].join()»
		
		«type.storageModifier.createClassAnnotation»
		public class «type.name» «if (type.parent != null) 'extends '+type.parent.name» {
			«type.properties.map[p | p.createProperty(type.storageModifier)].join()»
			
			«type.properties.map[p | p.createGettersAndSetters].join()»
		}
	'''
	
	/**
	 * Create the correct annotation for an entity class.
	 */
	def createClassAnnotation(TypeStorageModifier modifier) {
		switch(modifier) {
			case TypeStorageModifier::STORABLE :  '@Entity'
			case TypeStorageModifier::EMBEDDABLE : '@Embeddable'
		}
	}
	
	/**
	 * Create imports related to storage modifiers.
	 */
	def createImports(TypeStorageModifier modifier) {
		switch(modifier) {
			case TypeStorageModifier::STORABLE :  'import javax.persistence.Entity;'
			case TypeStorageModifier::EMBEDDABLE : 'import javax.persistence.Embeddable;'
		}
	}
	
	def createGettersAndSetters(Property property) '''
		public «property.type.createJavaType» get«property.name.toFirstUpper»() {
			return this.«property.name»;
		}
		
		public void set«property.name.toFirstUpper»(final «property.type.createJavaType» «property.name») {
			this.«property.name» = «property.name»;
		}
	'''
	
	def createProperty(Property property, TypeStorageModifier modifier) {
		if ((modifier == TypeStorageModifier::STORABLE) ||
			(modifier == TypeStorageModifier::EMBEDDABLE))
			switch (property.storageModifier) {
				case PropertyStorageModifier::TRANSIENT: return property.createTransientProperty
				case PropertyStorageModifier::VALUE: return property.createTransientProperty
				case PropertyStorageModifier::VARIABLE: return property.createStorableProperty
			}
		else
			return property.createNormalProperty
		
	}
	
	def createNormalProperty(Property property) '''
		private «if (property.storageModifier == PropertyStorageModifier::VALUE) 'final '»«property.type.createJavaType» «property.name»«if (property.literal != null) property.literal.createLiteral»;
	'''
	
	def createTransientProperty(Property property) '''
		private @Transient «if (property.storageModifier == PropertyStorageModifier::VALUE) 'final '»«property.type.createJavaType» «property.name»«if (property.literal != null) property.literal.createLiteral»;
	'''
	
	def createStorableProperty(Property property) {
		if (property.relationship == null) {
			'''private «property.type.createDatabaseType» «property.name»;'''
		} else {
			switch (property.relationship.kind) {
				case EntityRelationshipKind::UNIQUE: 
					switch (property.type) {
						// a forward or backward reference, depending on the mappedBy value, for the one-to-one case
						TypeReference: '''
							@OneToOne(cascade=CascadeType.ALL,«property.relationship.mappedBy?.createMappedBy»)
							private «property.type.createDatabaseType» «property.name»;'''
						// a containing forward reference for the one-to-many case
						CollectionType case property.relationship.mappedBy == null : '''
							@OneToMany
							private «property.type.createDatabaseType» «property.name»;'''
						// a back reference for a many-to-one relation
						CollectionType case property.relationship.mappedBy != null : '''
							@OneToMany(«property.relationship.mappedBy.createMappedBy»)
							private «property.type.createDatabaseType» «property.name»;'''
						// a containing forward reference for the one-to-many case
						MapType case property.relationship.mappedBy == null : '''
							@OneToMany
							@MapKey(name="«property.mapKey.reference.name»")
							private «property.type.createDatabaseType» «property.name»;'''
						// a back reference for the many-to-one case
						MapType case property.relationship.mappedBy == null : '''
							@OneToMany(«property.relationship.mappedBy.createMappedBy»)
							@MapKey(name="«property.mapKey.reference.name»")
							private «property.type.createDatabaseType» «property.name»;'''
					}
				case  EntityRelationshipKind::MANY: // TODO this code is broken/unfinished
					switch (property.type) {
						// TypeReference is never many
						// a back reference for the one-to-many case
						CollectionType case property.relationship.mappedBy != null : '''
							@OneToMany(«property.relationship.mappedBy.createMappedBy»)
							private «property.type.createDatabaseType» «property.name»;'''
						// a forward reference for the many-to-one case
						CollectionType case property.relationship.mappedBy != null : '''
							@ManyToOne(«property.relationship.mappedBy.createMappedBy»)
							private «property.type.createDatabaseType» «property.name»;'''
						MapType case property.relationship.mappedBy != null : '''
							@ManyToOne(«property.relationship.mappedBy.createMappedBy»)
							@MapKey(name="«property.mapKey.reference.name»")
							private «property.type.createDatabaseType» «property.name»;'''
						MapType case property.relationship.mappedBy != null : '''
							@ManyToOne(«property.relationship.mappedBy.createMappedBy»)
							@MapKey(name="«property.mapKey.reference.name»")
							private «property.type.createDatabaseType» «property.name»;'''
					}
			}
		}
	}
	
	/**
	 * Recursively create a path for the property mapped by reference.
	 */
	def CharSequence createMappedBy(MappedByReference reference) '''mappedBy="«reference.base.name»«reference.path?.createMappedByPath»"'''
	
	def CharSequence createMappedByPath(MappedByReference reference) '''«reference.base.name»«reference.path?.createMappedByPath»'''
	
/*	
	'''
		@OneToOne(cascade=CascadeType.ALL) unique
		@ManyToOne indicates that instances of the class can share the same reference to another object (reference)
		
		@OneToMany(mappedBy="property of the above mentioned class which shares the reference")
		implementes a bi-directional mapping
		
		@OrderBy("name") allows to order objects by one of its fields described in a @OneToMany mapping.
		@MapKey(name="name") maps the given property of the referenced class to a key value in a map.
		Therefore is only applicable for map types, which are not yet supported.
		
		«if (property.containment && property.type instanceof CollectionType && (property.eContainer as EntityType).storageModifier == TypeStorageModifier::STORABLE) '@OneToMany'»
		private «property.type.createDatabaseType» «property.name»;
	'''
	*/
	def createLiteral(Literal literal) {
		switch (literal) {
			PropertyReference : return '''null''' // this should be illegal
			StringLiteral : return literal.value
			CharLiteral : return "'" + literal.value + "'" 
			NumberLiteral : return literal.value
			BooleanLiteral : return if (literal.value) 'true' else 'false'
		}
	}
	
	dispatch def CharSequence createJavaType(TypeReference reference) {
		switch (reference.reference) {
			PrimitiveType case reference.reference.name.equals("string") : 'String'
			PrimitiveType case reference.reference.name.equals("currency") : 'double'
			PrimitiveType case reference.reference.name.equals("date") : 'Date'
			PrimitiveType : reference.reference.name
			default : reference.reference.name
		}
	}
	
	dispatch def CharSequence createJavaType(CollectionType reference) {
		if (reference.size != 0) '''
			«reference.reference.createJavaType»[«reference.size»]'''
		else '''
			List<«reference.reference.createJavaType»>'''
	}
		
	dispatch def CharSequence createDatabaseType(TypeReference reference) {
		switch (reference.reference) {
			PrimitiveType case reference.reference.name.equals("string") : 'String'
			PrimitiveType case reference.reference.name.equals("currency") : 'double'
			PrimitiveType case reference.reference.name.equals("date") : '@Temporal(TemporalType.TIMESTAMP) Date'
			PrimitiveType : reference.reference.name
			EnumerationType : '''@Enumerated(EnumType.ORDINAL) «reference.reference.name»'''
			default : reference.reference.name
		}
	}
	
	dispatch def CharSequence createDatabaseType(CollectionType reference) {
		if (reference.size != 0) '''
			«reference.reference._createJavaType»[«reference.size»]'''
		else '''
			List<«reference.reference._createJavaType»>'''
	}
	
	def createImport(Import imp) '''
		import «imp.importedNamespace»;
	'''
	
	
	
	
}
